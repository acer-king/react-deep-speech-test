{"version":3,"sources":["helper/wav-encoder/encoder.js","helper/inline-worker/index.js","helper/inline-worker/inline-worker.js","helper/wav-encoder/encoder-worker.js","helper/wav-encoder/index.js","helper/audio-resampler/resampler.js","components/RecordNow/RecordNow.js","App.js","serviceWorker.js","index.js"],"names":["_interopRequire","obj","__esModule","_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","InlineWorker","require","encoder","Encoder","_this","this","format","undefined","floatingPoint","bitDepth","_worker","self","onmessage","data","callback","_callbacks","callbackId","type","resolve","buffer","reject","Error","message","canProcess","encode","audioData","Promise","length","push","numberOfChannels","channelData","sampleRate","buffers","map","postMessage","module","exports","global","window","URL","Blob","Worker","func","setTimeout","call","e","then","bytes","writer","BufferWriter","writeString","writeUint32","writeUint16","Float32Array","writePCM","toArrayBuffer","ArrayBuffer","view","DataView","pos","setUint8","setUint16","setUint32","i","writeUint8","charCodeAt","x","Math","max","min","setInt8","setInt16","setInt32","setFloat32","setFloat64","method","ch","util","OfflineAudioContext","webkitOfflineAudioContext","AudioContext","webkitAudioContext","audioContext","wal","WebAudioLoader","context","cache","resampler","input","targetSampleRate","oncomplete","returnError","inputType","toString","load","onload","err","audioBuffer","resampleAudioBuffer","leftBuffer","numCh_","rightBuffer","createBuffer","errMsg","console","error","numFrames_","offlineContext_","bufferSource_","createBufferSource","resampeledBuffer","renderedBuffer","getAudioBuffer","getFile","fileCallback","getChannelData","WavEncoder","blob","createObjectURL","connect","destination","start","startRendering","MediaRecorder","OpusMediaRecorder","api_prod","workerOptions","OggOpusEncoderWasmPath","WebMOpusEncoderWasmPath","styles","audioContainer","display","justifyContent","justifySelf","width","minHeight","height","overflow","boxShadow","background","color","audioList","listStyle","paddingLeft","flexDirection","marginLeft","marginRight","paddingTop","audioItem","fontWeight","fontSize","padding","alignItems","header","headerDesc","buttonContainer","gridTemplateColumns","button","backgroundColor","borderStyle","borderRadius","downloadButton","RecordNow","canvasRef","useRef","listRef","useState","audioCtx","setAudioCtx","analyser","setAnalyser","dataArray","setDataArray","setActiveAnalyzer","speech","setSpeech","currentAudio","setCurrentAudio","recording","setRecording","recorder","setRecorder","mainStream","setMainStream","downloadLink","setDownloadLink","linkArray","setLinkArray","silence","setSilence","useEffect","close","createAnalyser","requestData","pause","myInterval","setInterval","getByteFrequencyData","current","getContext","fillStyle","clearRect","innerWidth","lineWidth","gradient","createLinearGradient","addColorStop","strokeStyle","beginPath","sliceWidth","y","moveTo","lineTo","stroke","draw","silenceCounter","noiseCounter","resume","state","clearInterval","addEventListener","a","size","File","event","fileEvent","log","sendAudio","file","index","fetch","r","myFileBlob","FormData","append","request","body","crossDomain","res","json","text","sent","status","catch","fetchInterval","some","item","suspend","stop","getTracks","forEach","track","Fragment","style","className","onClick","preventDefault","options","sampleSize","channelCount","mimeType","navigator","mediaDevices","getUserMedia","audio","video","stream","tempTrack","applyConstraints","createMediaStreamSource","fftSize","bufferLength","frequencyBinCount","Uint8Array","ref","href","download","textAlign","maxWidth","reverse","fullScreen","alignContent","gridTemplateRows","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.b71f67c2.chunk.js","sourcesContent":["\r\n\r\nconst _interopRequire = obj => obj && obj.__esModule ? obj[\"default\"] : obj;\r\n\r\nconst _createClass = (() => { function defineProperties(target, props) { for (const key in props) { const prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return (Constructor, protoProps, staticProps) => { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\r\n\r\nconst _classCallCheck = (instance, Constructor) => { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\r\n\r\n\r\n// custom inline-worker function modified to prevent breaking on production\r\nconst InlineWorker = _interopRequire(require(\"../inline-worker\"));\r\n\r\nconst encoder = _interopRequire(require(\"./encoder-worker.js\"));\r\n\r\nconst Encoder = (() => {\r\n  function Encoder(...args) {\r\n    const _this = this;\r\n\r\n    const format = args[0] === undefined ? {} : args[0];\r\n\r\n    _classCallCheck(this, Encoder);\r\n\r\n    this.format = {\r\n      floatingPoint: !!format.floatingPoint,\r\n      bitDepth: format.bitDepth | 0 || 16\r\n    };\r\n    this._worker = new InlineWorker(encoder, encoder.self);\r\n    this._worker.onmessage = ({ data }) => {\r\n      const callback = _this._callbacks[data.callbackId];\r\n\r\n      if (callback) {\r\n        if (data.type === \"encoded\") {\r\n          callback.resolve(data.buffer);\r\n        } else {\r\n          callback.reject(new Error(data.message));\r\n        }\r\n      }\r\n\r\n      _this._callbacks[data.callbackId] = null;\r\n    };\r\n    this._callbacks = [];\r\n  }\r\n\r\n  _createClass(Encoder, {\r\n    canProcess: {\r\n      value: function canProcess(format) {\r\n        return Encoder.canProcess(format);\r\n      }\r\n    },\r\n    encode: {\r\n      value: function encode(audioData, format) {\r\n        const _this = this;\r\n\r\n        if (format == null || typeof format !== \"object\") {\r\n          format = this.format;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n          const callbackId = _this._callbacks.length;\r\n\r\n          _this._callbacks.push({ resolve, reject });\r\n\r\n          const numberOfChannels = audioData.channelData.length;\r\n          const length = audioData.channelData[0].length;\r\n          const sampleRate = audioData.sampleRate;\r\n          const buffers = audioData.channelData.map(({ buffer }) => buffer);\r\n\r\n          audioData = { numberOfChannels, length, sampleRate, buffers };\r\n\r\n          _this._worker.postMessage({\r\n            type: \"encode\", audioData, format, callbackId\r\n          }, audioData.buffers);\r\n        });\r\n      }\r\n    }\r\n  }, {\r\n    canProcess: {\r\n      value: function canProcess(format) {\r\n        if (format && (format === \"wav\" || format.type === \"wav\")) {\r\n          return \"maybe\";\r\n        }\r\n        return \"\";\r\n      }\r\n    },\r\n    encode: {\r\n      value: function encode(audioData, format) {\r\n        return new Encoder(format).encode(audioData);\r\n      }\r\n    }\r\n  });\r\n\r\n  return Encoder;\r\n})();\r\n\r\nexport default Encoder;","\"use strict\";\r\n\r\nmodule.exports = require(\"./inline-worker\");","const _createClass = (() => { function defineProperties(target, props) { for (const key in props) { const prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return (Constructor, protoProps, staticProps) => { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\r\n\r\nconst _classCallCheck = (instance, Constructor) => { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\r\n\r\nconst WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);\r\n\r\nconst InlineWorker = (() => {\r\n  function InlineWorker(func, self) {\r\n    const _this = this;\r\n\r\n    _classCallCheck(this, InlineWorker);\r\n\r\n    ////Removed this line to prevent breaking on production\r\n    // if (WORKER_ENABLED) {\r\n    //   var functionBody = func.toString().trim().match(/^function\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}$/)[1];\r\n    //   var url = global.URL.createObjectURL(new global.Blob([functionBody], { type: \"text/javascript\" }));\r\n\r\n    //   return new global.Worker(url);\r\n    // }\r\n\r\n    this.self = self;\r\n    this.self.postMessage = data => {\r\n      setTimeout(() => {\r\n        _this.onmessage({ data });\r\n      }, 0);\r\n    };\r\n\r\n    setTimeout(() => {\r\n      func.call(self);\r\n    }, 0);\r\n  }\r\n\r\n  _createClass(InlineWorker, {\r\n    postMessage: {\r\n      value: function postMessage(data) {\r\n        const _this = this;\r\n\r\n        setTimeout(() => {\r\n          _this.self.onmessage({ data });\r\n        }, 0);\r\n      }\r\n    }\r\n  });\r\n\r\n  return InlineWorker;\r\n})();\r\n\r\nexport default InlineWorker;","const self = {};\r\nfunction encoder() {\r\n\r\n  self.onmessage = e => {\r\n    switch (e.data.type) {\r\n      case \"encode\":\r\n        self.encode(e.data.audioData, e.data.format).then(buffer => {\r\n          const data = {\r\n            type: \"encoded\",\r\n            callbackId: e.data.callbackId,\r\n            buffer\r\n          };\r\n          self.postMessage(data, [buffer]);\r\n        }, ({ message }) => {\r\n          const data = {\r\n            type: \"error\",\r\n            callbackId: e.data.callbackId,\r\n            message: message\r\n          };\r\n          self.postMessage(data);\r\n        });\r\n        break;\r\n    }\r\n  };\r\n\r\n  self.encode = (audioData, format) => {\r\n    format.floatingPoint = !!format.floatingPoint;\r\n    format.bitDepth = format.bitDepth | 0 || 16;\r\n\r\n    return new Promise(resolve => {\r\n      const numberOfChannels = audioData.numberOfChannels;\r\n      const sampleRate = audioData.sampleRate;\r\n      const bytes = format.bitDepth >> 3;\r\n      const length = audioData.length * numberOfChannels * bytes;\r\n      const writer = new BufferWriter(44 + length);\r\n\r\n      writer.writeString(\"RIFF\"); // RIFF header\r\n      writer.writeUint32(writer.length - 8); // file length\r\n      writer.writeString(\"WAVE\"); // RIFF Type\r\n\r\n      writer.writeString(\"fmt \"); // format chunk identifier\r\n      writer.writeUint32(16); // format chunk length\r\n      writer.writeUint16(format.floatingPoint ? 3 : 1); // format (PCM)\r\n      writer.writeUint16(numberOfChannels); // number of channels\r\n      writer.writeUint32(sampleRate); // sample rate\r\n      writer.writeUint32(sampleRate * numberOfChannels * bytes); // byte rate\r\n      writer.writeUint16(numberOfChannels * bytes); // block size\r\n      writer.writeUint16(format.bitDepth); // bits per sample\r\n\r\n      writer.writeString(\"data\"); // data chunk identifier\r\n      writer.writeUint32(length); // data chunk length\r\n\r\n      const channelData = audioData.buffers.map(buffer => new Float32Array(buffer));\r\n\r\n      writer.writePCM(channelData, format);\r\n\r\n      resolve(writer.toArrayBuffer());\r\n    });\r\n  };\r\n\r\n  class BufferWriter {\r\n    constructor(length) {\r\n      this.buffer = new ArrayBuffer(length);\r\n      this.view = new DataView(this.buffer);\r\n      this.length = length;\r\n      this.pos = 0;\r\n    }\r\n\r\n    writeUint8(data) {\r\n      this.view.setUint8(this.pos, data);\r\n      this.pos += 1;\r\n    }\r\n\r\n    writeUint16(data) {\r\n      this.view.setUint16(this.pos, data, true);\r\n      this.pos += 2;\r\n    }\r\n\r\n    writeUint32(data) {\r\n      this.view.setUint32(this.pos, data, true);\r\n      this.pos += 4;\r\n    }\r\n\r\n    writeString(data) {\r\n      for (let i = 0; i < data.length; i++) {\r\n        this.writeUint8(data.charCodeAt(i));\r\n      }\r\n    }\r\n\r\n    writePCM8(x) {\r\n      x = Math.max(-128, Math.min(x * 128, 127)) | 0;\r\n      this.view.setInt8(this.pos, x);\r\n      this.pos += 1;\r\n    }\r\n\r\n    writePCM16(x) {\r\n      x = Math.max(-32768, Math.min(x * 32768, 32767)) | 0;\r\n      this.view.setInt16(this.pos, x, true);\r\n      this.pos += 2;\r\n    }\r\n\r\n    writePCM24(x) {\r\n      x = Math.max(-8388608, Math.min(x * 8388608, 8388607)) | 0;\r\n      this.view.setUint8(this.pos + 0, x >> 0 & 255);\r\n      this.view.setUint8(this.pos + 1, x >> 8 & 255);\r\n      this.view.setUint8(this.pos + 2, x >> 16 & 255);\r\n      this.pos += 3;\r\n    }\r\n\r\n    writePCM32(x) {\r\n      x = Math.max(-2147483648, Math.min(x * 2147483648, 2147483647)) | 0;\r\n      this.view.setInt32(this.pos, x, true);\r\n      this.pos += 4;\r\n    }\r\n\r\n    writePCM32F(x) {\r\n      this.view.setFloat32(this.pos, x, true);\r\n      this.pos += 4;\r\n    }\r\n\r\n    writePCM64F(x) {\r\n      this.view.setFloat64(this.pos, x, true);\r\n      this.pos += 8;\r\n    }\r\n\r\n    writePCM(channelData, { bitDepth, floatingPoint }) {\r\n      const length = channelData[0].length;\r\n      const numberOfChannels = channelData.length;\r\n      let method = `writePCM${bitDepth}`;\r\n\r\n      if (floatingPoint) {\r\n        method += \"F\";\r\n      }\r\n\r\n      if (!this[method]) {\r\n        throw new Error(`not suppoerted bit depth ${bitDepth}`);\r\n      }\r\n\r\n      for (let i = 0; i < length; i++) {\r\n        for (let ch = 0; ch < numberOfChannels; ch++) {\r\n          this[method](channelData[ch][i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    toArrayBuffer() {\r\n      return this.buffer;\r\n    }\r\n  }\r\n\r\n  self.BufferWriter = BufferWriter;\r\n}\r\n\r\nencoder.self = encoder.util = self;\r\n\r\nexport default encoder;","const _interopRequire = obj => obj && obj.__esModule ? obj[\"default\"] : obj;\r\n\r\nconst Encoder = _interopRequire(require(\"./encoder\"));\r\n\r\nexport default Encoder;","//custom wavencoder\r\nimport WavEncoder from \"../wav-encoder\";\r\nimport WebAudioLoader from 'webaudioloader';\r\n\r\n\r\n// WebAudio Shim.\r\nwindow.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;\r\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\nconst audioContext = new AudioContext();\r\n\r\nconst wal = new WebAudioLoader({\r\n    context: audioContext,\r\n    cache: false\r\n});\r\n\r\nfunction resampler(input, targetSampleRate, oncomplete) {\r\n\r\n    if (!input && !targetSampleRate) {\r\n        return returnError('Error: First argument should be either a File, URL or AudioBuffer');\r\n    }\r\n\r\n    const inputType = Object.prototype.toString.call(input);\r\n    if (inputType !== '[object String]' &&\r\n        inputType !== '[object File]' &&\r\n        inputType !== '[object AudioBuffer]' &&\r\n        inputType !== '[object Object]') {\r\n        return returnError('Error: First argument should be either a File, URL or AudioBuffer');\r\n    }\r\n\r\n    if (typeof targetSampleRate !== 'number' ||\r\n        targetSampleRate > 192000 || targetSampleRate < 3000) {\r\n        return returnError('Error: Second argument should be a numeric sample rate between 3000 and 192000');\r\n    }\r\n\r\n    if (inputType === '[object String]' || inputType === '[object File]') {\r\n        // console.log('Loading/decoding input', input);\r\n        wal.load(input, {\r\n            onload(err, audioBuffer) {\r\n                if (err) {\r\n                    return returnError(err);\r\n                }\r\n                resampleAudioBuffer(audioBuffer);\r\n            }\r\n        });\r\n    } else if (inputType === '[object AudioBuffer]') {\r\n        resampleAudioBuffer(input);\r\n    } else if (inputType === '[object Object]' && input.leftBuffer && input.sampleRate) {\r\n        const numCh_ = input.rightBuffer ? 2 : 1;\r\n        const audioBuffer_ = audioContext.createBuffer(numCh_, input.leftBuffer.length, input.sampleRate);\r\n        resampleAudioBuffer(audioBuffer_);\r\n    } else {\r\n        return returnError('Error: Unknown input type');\r\n    }\r\n\r\n    function returnError(errMsg) {\r\n        console.error(errMsg);\r\n        if (typeof oncomplete === 'function') {\r\n            oncomplete(new Error(errMsg));\r\n        }\r\n        return;\r\n    }\r\n\r\n    function resampleAudioBuffer(audioBuffer) {\r\n\r\n\r\n        const numCh_ = audioBuffer.numberOfChannels;\r\n        const numFrames_ = audioBuffer.length * targetSampleRate / audioBuffer.sampleRate;\r\n\r\n        const offlineContext_ = new OfflineAudioContext(numCh_, numFrames_, targetSampleRate);\r\n        const bufferSource_ = offlineContext_.createBufferSource();\r\n        bufferSource_.buffer = audioBuffer;\r\n\r\n        offlineContext_.oncomplete = ({ renderedBuffer }) => {\r\n            const resampeledBuffer = renderedBuffer;\r\n            // console.log('Done Rendering');\r\n            if (typeof oncomplete === 'function') {\r\n                oncomplete({\r\n                    getAudioBuffer() {\r\n                        return resampeledBuffer;\r\n                    },\r\n                    getFile(fileCallback) {\r\n                        const audioData = {\r\n                            sampleRate: resampeledBuffer.sampleRate,\r\n                            channelData: []\r\n                        };\r\n                        for (let i = 0; i < resampeledBuffer.numberOfChannels; i++) {\r\n                            audioData.channelData[i] = resampeledBuffer.getChannelData(i);\r\n                        }\r\n                        WavEncoder.encode(audioData).then(buffer => {\r\n                            const blob = new Blob([buffer], {\r\n                                type: \"audio/wav\"\r\n                            });\r\n                            fileCallback(URL.createObjectURL(blob));\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        // console.log('Starting Offline Rendering');\r\n        bufferSource_.connect(offlineContext_.destination);\r\n        bufferSource_.start(0);\r\n        offlineContext_.startRendering();\r\n    }\r\n}\r\n\r\nexport default resampler;\r\n","import React, { useState, useEffect, useRef } from 'react';\r\nimport './RecordNow.css';\r\n\r\n//Audio File Resampler\r\n//modified audio-resampler package for this project including it's dependencies\r\nimport resampler from '../../helper/audio-resampler';\r\n\r\n//icons\r\nimport MicIcon from '@material-ui/icons/Mic';\r\nimport RecordingIcon from '@material-ui/icons/RadioButtonChecked';\r\nimport GetAppIcon from '@material-ui/icons/GetApp';\r\nimport QueueIcon from '@material-ui/icons/Timer';\r\nimport ProcessingIcon from '@material-ui/icons/Equalizer';\r\n// import CompleteIcon from '@material-ui/icons/DoneOutline';\r\nimport CompleteIcon from '@material-ui/icons/Done';\r\nimport HearingIcon from '@material-ui/icons/Hearing';\r\nimport SpeakingIcon from '@material-ui/icons/RecordVoiceOver';\r\nimport MicOffIcon from '@material-ui/icons/MicOff';\r\n//setting default MediaRecorder to OpusMediaRecorder\r\nwindow.MediaRecorder = window.OpusMediaRecorder;\r\nconst api_prod = 'https://www.deeplanguagesync.com/api/v1/getVoice'\r\n// Non-standard options for opus media recorder\r\nconst workerOptions = {\r\n    OggOpusEncoderWasmPath: 'https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/OggOpusEncoder.wasm',\r\n    WebMOpusEncoderWasmPath: 'https://cdn.jsdelivr.net/npm/opus-media-recorder@latest/WebMOpusEncoder.wasm'\r\n};\r\n\r\nlet audioData = []\r\n\r\nconst RecordNow = () => {\r\n    const canvasRef = useRef();\r\n    const listRef = useRef();\r\n    //analyzer context\r\n    //for testing \"record until silence\"\r\n    const [audioCtx, setAudioCtx] = useState();\r\n    const [analyser, setAnalyser] = useState();\r\n    const [dataArray, setDataArray] = useState();\r\n    const [activeAnalyzer, setActiveAnalyzer] = useState(null);\r\n    //array of responses\r\n    const [text, setText] = useState(null)\r\n    const [speech, setSpeech] = useState([]);\r\n    const [currentAudio, setCurrentAudio] = useState(null)\r\n\r\n    const [recording, setRecording] = useState(false);\r\n    const [recorder, setRecorder] = useState(false);\r\n    const [mainStream, setMainStream] = useState(false);\r\n    const [downloadLink, setDownloadLink] = useState();\r\n    const [linkArray, setLinkArray] = useState([])\r\n    const [silence, setSilence] = useState(0)\r\n\r\n    const draw = () => {\r\n        canvasRef.current.getContext('2d').fillStyle = 'rgb(255, 255, 255,0.5)';\r\n        //canvasRef.current.getContext('2d').fillStyle = \"rgba(0, 0, 0, 0.5)\"\r\n        //canvasRef.current.getContext('2d').fillRect(0, 0, window.innerWidth, 150);\r\n        canvasRef.current.getContext('2d').clearRect(0, 0, window.innerWidth, 100);\r\n        canvasRef.current.getContext('2d').lineWidth = 2;\r\n        var gradient = canvasRef.current.getContext('2d').createLinearGradient(0, 0, window.innerWidth, 0);\r\n        gradient.addColorStop(\"0\", \"magenta\");\r\n        gradient.addColorStop(\"0.2\", \"blue\");\r\n        gradient.addColorStop(\"0.5\", \"green\");\r\n        gradient.addColorStop(\"0.8\", \"blue\");\r\n        gradient.addColorStop(\"1.0\", \"green\");\r\n        canvasRef.current.getContext('2d').strokeStyle = gradient;\r\n        canvasRef.current.getContext('2d').beginPath();\r\n\r\n        if (dataArray) {\r\n            //console.log('getting array');\r\n            //console.log(dataArray)\r\n            let sliceWidth = window.innerWidth / dataArray.length;\r\n            let x = 0;\r\n            // let maxPoint = (Math.max(...dataArray));\r\n            // console.log('maxPoint', maxPoint)\r\n            // let buff = maxPoint < 200 ? 50 : 0\r\n            for (var i = 0; i < dataArray.length; i++) {\r\n\r\n                var y = (-(dataArray[i]) * (75 / 255));\r\n                //var y = v * 100 / 2;\r\n\r\n                if (i === 0) {\r\n                    canvasRef.current.getContext('2d').moveTo(x, y + 75);\r\n                } else {\r\n                    canvasRef.current.getContext('2d').lineTo(x, y + 75);\r\n                    //canvasRef.current.getContext('2d').lineTo(x, 100);\r\n                }\r\n                x += sliceWidth;\r\n            }\r\n\r\n        }\r\n        canvasRef.current.getContext('2d').lineTo(window.innerWidth, 75);\r\n        canvasRef.current.getContext('2d').stroke();\r\n\r\n    }\r\n\r\n\r\n    //start audio context\r\n    useEffect(() => {\r\n        setAudioCtx(new (window.AudioContext || window.webkitAudioContext)());\r\n        //cleanup, close audioCtx\r\n        return () => { audioCtx.close() }\r\n    }, []);\r\n\r\n    //initialize analyzer from audio context\r\n    useEffect(() => {\r\n        if (audioCtx) {\r\n            setAnalyser(audioCtx.createAnalyser());\r\n        }\r\n    }, [audioCtx]);\r\n\r\n    // handling threashold silences while recording\r\n    useEffect(() => {\r\n        //console.log('current silence length in ms ', silence)\r\n        //1.5 seconds pause will split the files\r\n        if (silence > 100) {\r\n            //console.log('requesting data')\r\n            setSilence(0);\r\n            // Requests a Blob containing the saved data received thus far (After calling method requestData() recording continues, but in a new Blob)\r\n            recorder.requestData();\r\n            recorder.pause();\r\n        }\r\n    }, [silence])\r\n\r\n\r\n    // Looking for silence in the dataArray\r\n    useEffect(() => {\r\n        let myInterval;\r\n        // console.log('here')\r\n        if (dataArray && recording) {\r\n            myInterval = setInterval(() => {\r\n                setActiveAnalyzer(analyser.getByteFrequencyData(dataArray));\r\n                // for the voice graph\r\n                draw();\r\n                //console.log(dataArray);\r\n                let silenceCounter = 0;\r\n                let noiseCounter = 0;\r\n                for (let i in dataArray) {\r\n                    // values between 0-255, 0 means not amplitude (silence)\r\n                    if (dataArray[i] <= 40) {\r\n                        silenceCounter++;\r\n                    } else {\r\n                        //sound found in this array\r\n                        //console.log('found on index:', i);\r\n                        noiseCounter++;\r\n                    }\r\n                    //in this dataArray how many 0s were found\r\n                    if (noiseCounter > 100) {\r\n                        recorder.resume();\r\n                        break;\r\n                    }\r\n                    //in this dataArray how many 0s were found\r\n                    if (silenceCounter > 1000 && recorder.state === 'recording') {\r\n                        setSilence(silence + 1);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n\r\n                // console.log('silenceCounter', silenceCounter);\r\n                // console.log('noiseCounter', noiseCounter);\r\n            }, 5)\r\n        } else if (!recording) {\r\n            clearInterval(myInterval)\r\n        }\r\n        //cleanup\r\n        return () => { clearInterval(myInterval) }\r\n    }, [dataArray, recording, silence]);\r\n\r\n    //handle stop and dataavailable listeners along with sound resampling\r\n    useEffect(() => {\r\n        if (recorder) {\r\n            //setRecorder(new MediaRecorder(stream, options));\r\n            recorder.addEventListener('dataavailable', async (e) => {\r\n                // console.log('stream stopped, now data is available');\r\n                if (e.data.size > 0) {\r\n                    // console.log('blobsize', e.data.size)\r\n                    // console.log(e.data);\r\n                    // console.log(URL.createObjectURL(e.data));\r\n                    //Opus Media Recorder defaults recording wav files to 44.1KHZ so need to resample to 16khz for deepspeech to analyze it. resampler package resample wav audio file and returns a URL\r\n                    await resampler(new File([e.data], \"audio.wav\"), 16000, async (event) => {\r\n                        // console.log('=============================', event);\r\n                        // console.log(event instanceof Error);\r\n\r\n                        // let audio = await event.getAudioBuffer()\r\n                        // var audioData = {\r\n                        //     sampleRate: audio.sampleRate,\r\n                        //     channelData: []\r\n                        // };\r\n                        // for (var i = 0; i < audio.numberOfChannels; i++) {\r\n                        //     audioData.channelData[i] = audio.getChannelData(i);\r\n                        // }\r\n                        // console.log('encoding')\r\n                        // await WavEncoder.encode(audioData).then(function (buffer) {\r\n                        //     console.log('error here?')\r\n                        //     var blob = new Blob([buffer], {\r\n                        //         type: \"audio/wav\"\r\n                        //     });\r\n                        //     console.log(URL.createObjectURL(blob));\r\n                        // });\r\n                        // console.log('encoding finished')\r\n\r\n                        if (!(event instanceof Error)) {\r\n                            // console.log(event.getAudioBuffer());\r\n\r\n                            event.getFile((fileEvent) => {\r\n                                //sendAudio(fileEvent);\r\n                                //sendAudio(event.getAudioBuffer());\r\n                                // console.log('downloadlink', downloadLink);\r\n                                setDownloadLink(fileEvent);\r\n                                // setSpeech([\r\n                                //     ...speech,\r\n                                //     {\r\n                                //         file: fileEvent,\r\n                                //         text: '',\r\n                                //         sent: false,\r\n                                //         status: 'queue'\r\n                                //     }\r\n                                // ])\r\n                                setCurrentAudio(fileEvent);\r\n                                // console.log('new file', new file)\r\n                            });\r\n                        }\r\n\r\n                    });\r\n\r\n\r\n                    // setDownloadLink(URL.createObjectURL(e.data));\r\n                }\r\n            });\r\n\r\n            recorder.addEventListener('stop', () => {\r\n                console.log('ended');\r\n                // console.log('stopped');\r\n            });\r\n        }\r\n    }, [recorder]);\r\n\r\n\r\n    //add download link created from the resampler package to the link array \r\n    useEffect(() => {\r\n        if (downloadLink) {\r\n            setLinkArray([...linkArray, downloadLink]);\r\n        }\r\n    }, [downloadLink])\r\n\r\n    // add new object to the speech array\r\n    // useEffect(() => {\r\n    //     if (currentAudio) {\r\n    //         setSpeech([\r\n    //             ...speech,\r\n    //             {\r\n    //                 file: currentAudio,\r\n    //                 text: '',\r\n    //                 sent: false,\r\n    //                 status: 'queue'\r\n    //             }\r\n    //         ])\r\n    //     }\r\n\r\n    // }, [currentAudio]);\r\n\r\n    useEffect(() => {\r\n        const sendAudio = async (file, index) => {\r\n\r\n            // setSpeech([\r\n            //     ...speech,\r\n            //     {\r\n            //         file: file,\r\n            //         text: '',\r\n            //         sent: true,\r\n            //         status: 'Processing'\r\n            //     }\r\n            // ])\r\n\r\n            // console.log('sending audio')\r\n            // console.log(file)\r\n            //URL to file using fetch\r\n            let blob = await fetch(file).then(r => r.blob());\r\n            let myFileBlob = new File([blob], \"audio.wav\");\r\n            // let myFileBlob = new Blob([blob], {\r\n            //     type: \"audio/wav\"\r\n            // });\r\n            const data = new FormData;\r\n            data.append('audio', myFileBlob);\r\n            //data.append('audio', file, { filename: 'audio.wav' });\r\n\r\n            let request = {\r\n                method: 'POST',\r\n                body: data,\r\n                crossDomain: true,\r\n            }\r\n            // console.log('trying to send')\r\n            return await fetch(api_prod, request)\r\n                .then((res) => res.json())\r\n                .then(res => {\r\n                    // console.log('nothing here')\r\n                    // console.log(res);\r\n                    if (res.message === 'success') {\r\n                        //setText([...text, res.data])\r\n\r\n\r\n                        // setSpeech([\r\n                        //     ...speech,\r\n                        //     {\r\n                        //         file: file,\r\n                        //         text: res.data,\r\n                        //         sent: true,\r\n                        //         status: 'Complete'\r\n                        //     }\r\n                        // ])\r\n                        audioData[index] = {\r\n                            file: file,\r\n                            text: res.data,\r\n                            sent: true,\r\n                            status: 'complete'\r\n                        }\r\n\r\n                        return\r\n                    } else if (res.error) {\r\n                        // setSpeech([\r\n                        //     ...speech\r\n                        //     {\r\n                        //         file: file,\r\n                        //         text: res.error,\r\n                        //         sent: true,\r\n                        //         status: 'Complete',\r\n                        //         error: res.error\r\n                        //     }\r\n                        // ])\r\n                        audioData[index] = {\r\n                            file: file,\r\n                            text: res.error,\r\n                            sent: true,\r\n                            status: 'complete',\r\n                            error: res.error\r\n                        }\r\n\r\n                        return\r\n                    }\r\n                })\r\n                .catch(err => console.log(err));\r\n\r\n        }\r\n\r\n\r\n        let fetchInterval = setInterval(() => {\r\n            setSpeech([...audioData]);\r\n            if (!audioData.some(item => item.status === 'processing')) {\r\n                if (audioData.some(item => item.status === 'queue')) {\r\n                    for (let i = 0; i < audioData.length; i++) {\r\n                        if (audioData[i].status === 'queue') {\r\n                            audioData[i].status = 'processing';\r\n                            sendAudio(audioData[i].file, i)\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }, 100);\r\n        // fetchInterval();\r\n        return () => { clearInterval(fetchInterval) }\r\n    }, [])\r\n\r\n\r\n    //handle speech object array\r\n    useEffect(() => {\r\n        // console.log('speech effect', speech)\r\n        const sendAudio = async (file) => {\r\n            // tempSpeech[tempSpeech.length - 1] = {\r\n            //     file: speech[speech.length - 1].file,\r\n            //     text: '',\r\n            //     sent: true,\r\n            //     status: 'processing'\r\n            // }\r\n            // setSpeech(tempSpeech);\r\n            setSpeech([\r\n                ...speech,\r\n                {\r\n                    file: file,\r\n                    text: '',\r\n                    sent: true,\r\n                    status: 'Processing'\r\n                }\r\n            ])\r\n\r\n            // console.log('sending audio')\r\n            // console.log(file)\r\n            //URL to file using fetch\r\n            let blob = await fetch(file).then(r => r.blob());\r\n            let myFileBlob = new File([blob], \"audio.wav\");\r\n            // let myFileBlob = new Blob([blob], {\r\n            //     type: \"audio/wav\"\r\n            // });\r\n            const data = new FormData;\r\n            data.append('audio', myFileBlob);\r\n            //data.append('audio', file, { filename: 'audio.wav' });\r\n\r\n            let request = {\r\n                method: 'POST',\r\n                body: data,\r\n                crossDomain: true\r\n            }\r\n            // console.log('trying to send')\r\n            return await fetch(api_prod, request)\r\n                .then((res) => res.json())\r\n                .then(res => {\r\n                    // console.log('nothing here')\r\n                    // console.log(res);\r\n                    if (res.message === 'success') {\r\n                        //setText([...text, res.data])\r\n\r\n                        // tempSpeech[tempSpeech.length - 1] = {\r\n                        //     file: tempSpeech[tempSpeech.length - 1].file,\r\n                        //     text: res.data,\r\n                        //     sent: true,\r\n                        //     status: 'complete'\r\n                        // }\r\n                        // console.log(tempSpeech);\r\n                        // setSpeech(tempSpeech)\r\n                        setSpeech([\r\n                            ...speech,\r\n                            {\r\n                                file: file,\r\n                                text: res.data,\r\n                                sent: true,\r\n                                status: 'Complete'\r\n                            }\r\n                        ])\r\n                        return {\r\n                            file: file,\r\n                            text: res.data,\r\n                            sent: true,\r\n                            status: 'Complete'\r\n                        }\r\n                    } else if (res.error) {\r\n                        setSpeech([\r\n                            ...speech,\r\n                            {\r\n                                file: file,\r\n                                text: res.error,\r\n                                sent: true,\r\n                                status: 'Complete',\r\n                                error: res.error\r\n                            }\r\n                        ])\r\n                        return {\r\n                            file: file,\r\n                            text: res.error,\r\n                            sent: true,\r\n                            status: 'Complete',\r\n                            error: res.error\r\n                        }\r\n                    }\r\n                })\r\n                .catch(err => console.log(err));\r\n\r\n        }\r\n        // console.log(speech)\r\n        // if (speech.length > 0 && !speech[speech.length - 1].sent) {\r\n        //     console.log('status =', speech.length, '=====', speech[speech.length - 1].sent)\r\n        //     console.log(speech)\r\n        //     sendAudio(speech[speech.length - 1].file)\r\n        // }\r\n        const asyncCheck = async () => {\r\n            audioData = await audioData.map(async (audio, index) => {\r\n                if (audio.status === 'queue') {\r\n                    return await sendAudio(audio.file)\r\n                } else {\r\n                    return audio\r\n                }\r\n\r\n            });\r\n            // setSpeech(await audioData);\r\n            //console.log(audioData)\r\n        }\r\n\r\n        if (currentAudio) {\r\n            // setSpeech([\r\n            //     ...speech,\r\n            //     {\r\n            //         file: currentAudio,\r\n            //         text: '',\r\n            //         sent: false,\r\n            //         status: 'queue'\r\n            //     }\r\n            // ])\r\n            audioData.push({\r\n                file: currentAudio,\r\n                text: '',\r\n                sent: false,\r\n                status: 'queue'\r\n            })\r\n            //console.log(audioData);\r\n            //asyncCheck();\r\n            //sendAudio(currentAudio)\r\n        }\r\n\r\n    }, [currentAudio]);\r\n\r\n    // useEffect(()=>{\r\n\r\n    // },[speech])\r\n\r\n\r\n\r\n    //recorder object has been set and now we need to start recording\r\n    useEffect(() => {\r\n        if (recording) {\r\n            //starting to record\r\n            audioCtx.resume();\r\n            recorder.start();\r\n        } else if (!recording && recorder) {\r\n            if (recorder.state === 'paused') {\r\n                recorder.resume();\r\n            }\r\n            //stop recording\r\n            audioCtx.suspend();\r\n            //Check state here\r\n\r\n            recorder.stop();\r\n\r\n            //stopping the mainstream tracks (closing mic streaming)\r\n            mainStream.getTracks().forEach(function (track) {\r\n                //console.log('track', track.getConstraints())\r\n                //track.applyConstraints({ sampleSize: 16, channelCount: 2, echoCancellation: false, sampleRate: 16000 })\r\n                //console.log('track', track.getConstraints())\r\n                track.stop();\r\n            });\r\n\r\n        }\r\n    }, [recording]);\r\n\r\n    const sendAudio = async (file) => {\r\n        // console.log('sending audio')\r\n        //console.log(file)\r\n        //URL to file using fetch\r\n        let blob = await fetch(file).then(r => r.blob());\r\n        let myFileBlob = new File([blob], \"audio.wav\");\r\n        // let myFileBlob = new Blob([blob], {\r\n        //     type: \"audio/wav\"\r\n        // });\r\n        const data = new FormData;\r\n        data.append('audio', myFileBlob);\r\n        //data.append('audio', file, { filename: 'audio.wav' });\r\n\r\n        let request = {\r\n            method: 'POST',\r\n            body: data,\r\n            crossDomain: true,\r\n        }\r\n\r\n        await fetch('http://localhost:3001/api/v1/getVoice', request)\r\n            .then((res) => res.json())\r\n            .then(res => {\r\n                //console.log(res);\r\n                if (res.message === 'success') {\r\n                    setText([...text, res.data])\r\n                }\r\n\r\n            })\r\n            .catch(err => console.log(err));\r\n\r\n    }\r\n\r\n    //handles recording on off\r\n    const handleClick = (e) => {\r\n        e.preventDefault();\r\n        // console.log('running = ', !recording);\r\n\r\n        if (recording) {\r\n            // change recording status\r\n            setRecording(false);\r\n        } else {\r\n            const options = {\r\n                sampleSize: 16,\r\n                sampleRate: 56000,\r\n                channelCount: 1,\r\n                mimeType: 'audio/wav'\r\n            };\r\n\r\n            //requestion microphone access\r\n            navigator.mediaDevices.getUserMedia({ audio: true, video: false })\r\n                .then(async (stream) => {\r\n                    //temp track is needed for original MediaRecorder Object to set optional constraints\r\n                    let tempTrack = stream.getTracks()[0];\r\n                    await tempTrack.applyConstraints(options);\r\n                    //tempTrack is a reference for stream, so tempTrack=== stream\r\n                    setMainStream(stream);\r\n                    setRecorder(new MediaRecorder(stream, options, workerOptions));\r\n                    // change recording status\r\n                    setRecording(true);\r\n\r\n\r\n                    //analize sound waves\r\n                    let source = audioCtx.createMediaStreamSource(stream);\r\n                    source.connect(analyser);\r\n\r\n                    analyser.fftSize = 2048;\r\n                    // let bufferLength = analyser.frequencyBinCount;\r\n                    // let dataArray = new Uint8Array(bufferLength);\r\n                    // console.log(dataArray);\r\n                    let bufferLength = analyser.frequencyBinCount;\r\n                    // let dataArray = new Uint8Array(bufferLength);\r\n                    setDataArray(new Uint8Array(bufferLength))\r\n\r\n\r\n                    // setInterval(() => {\r\n                    //     analyser.getByteFrequencyData(dataArray);\r\n                    //     //analyser.getByteFrequencyData(dataArray);\r\n\r\n                    //     console.log(dataArray);\r\n                    // }, 100)\r\n\r\n\r\n                    // analyser.connect(distortion);\r\n                    // distortion.connect(audioCtx.destination);\r\n\r\n                });\r\n\r\n        }\r\n    }\r\n\r\n\r\n    return (\r\n        <React.Fragment>\r\n            <section style={styles.header}>\r\n                <div style={styles.buttonContainer}>\r\n                    <button className='button' style={styles.button} onClick={handleClick}>{recording ? <RecordingIcon className={'animate-flicker'} style={{ marginLeft: '20px', marginRight: '10px', color: 'red', fontSize: '35px' }} /> : <MicIcon style={{ marginLeft: '20px', marginRight: '10px', color: '#42ec42', fontSize: '35px' }} />}\r\n                        {recording ? 'Stop' : 'Start'}\r\n                    </button>\r\n                    {/* <span>{recorder.state}</span> */}\r\n                    <div style={styles.headerDesc}>\r\n                        <p>Press start to activate text to speech recognition using deepspeech . This tool will recognize pauses in speech and trimm audio accordingly, give it a try!</p>\r\n                    </div>\r\n                </div>\r\n                <canvas ref={canvasRef} width={window.innerWidth} height=\"100\" />\r\n                <div style={styles.audioItem} style={{ height: '35px', marginLeft: '30px' }}>\r\n                    {recorder.state === 'inactive' && <span style={{ display: 'flex' }}><MicOffIcon style={{ marginRight: '5px' }} /> Stopped</span>}\r\n                    {recorder.state === 'recording' && <span style={{ display: 'flex' }}><HearingIcon style={{ marginRight: '5px' }} /> Okay I'm Listening</span>}\r\n                    {recorder.state === 'paused' && <span style={{ display: 'flex' }}><SpeakingIcon style={{ marginRight: '5px' }} /> Hmmm please speak up!</span>}\r\n                </div>\r\n            </section>\r\n            <div style={styles.audioContainer}>\r\n                <ul ref={listRef} style={styles.audioList}>\r\n                    {speech && speech.map((item, index) =>\r\n\r\n                        <li key={index} style={styles.audioItem}>\r\n                            <a className='downloadButton' href={item.file} download={`audio${index + 1}.wav`} style={styles.downloadButton}> <GetAppIcon style={{ width: '50px' }} /></a>\r\n                            <div style={{ display: 'flex', width: '20px' }}><span style={{ width: '50px' }}>{index + 1}</span></div>\r\n                            <div style={{ display: 'flex', width: '50px' }}>\r\n                                {item.status === 'queue' && <QueueIcon className={'animate-flicker'} style={{ color: 'blueviolet', marginLeft: '5px' }} />}\r\n                                {item.status === 'processing' && <ProcessingIcon className={'animate-flicker'} style={{ color: '#00feff', marginLeft: '5px' }} />}\r\n                                {item.status === 'complete' && <CompleteIcon style={{ color: 'limegreen', marginLeft: '5px' }} />}\r\n                            </div>\r\n                            <span style={{ color: item.error ? '#ff6d15' : 'unset', fontWeight: item.error ? 500 : 600, textAlign: 'left', maxWidth: '70vw' }} >{item.text}</span>\r\n                        </li>\r\n                    ).reverse()}\r\n\r\n                </ul>\r\n            </div>\r\n\r\n\r\n        </React.Fragment>\r\n    )\r\n}\r\n\r\nconst styles = {\r\n    audioContainer: {\r\n        display: 'flex',\r\n        justifyContent: 'center',\r\n        justifySelf: 'center',\r\n        width: '100%',\r\n        minHeight: '100px',\r\n        height: '100%',\r\n        overflow: 'scroll',\r\n        //borderRadius: '5px',\r\n        boxShadow: '1px 1px 4px -2px',\r\n        background: '#1d1d1d',\r\n        color: 'white',\r\n    },\r\n    audioList: {\r\n        display: 'inline-flex',\r\n        listStyle: 'none',\r\n        width: '100%',\r\n        paddingLeft: 0,\r\n        flexDirection: 'column',\r\n        // justifyContent: 'flex-end', //bug using this with overflow hidden\r\n        // marginTop: 'auto',\r\n        overflow: 'scroll',\r\n        marginLeft: '15px',\r\n        marginRight: '15px',\r\n        paddingTop: '30px'\r\n    },\r\n    audioItem: {\r\n        fontWeight: 100,\r\n        fontSize: '15px',\r\n        padding: '5px 15px',\r\n        display: 'flex',\r\n        alignItems: 'center'\r\n\r\n        // top: (index === speech.length - 1) ? '0px' : `${(speech.length - index - 1) * 15}px`, zIndex: index, \r\n        // margin: '2px',\r\n        // boxShadow: '0px 0px 8px -2px',\r\n        // position: 'relative',\r\n        // /* z-index: 100, */\r\n        // backgroundColor: 'white',\r\n    },\r\n    header: {\r\n        //position: 'absolute',\r\n        background: 'linear-gradient(-30deg, #d754ad 0%, #d754ad 10%, #f96785 62%, #fe7333 100%)',\r\n        width: '100%',\r\n        height: '285px',\r\n        // display: 'flex',\r\n        display: 'flow-root',\r\n        alignItems: 'center',\r\n    },\r\n    headerDesc: {\r\n        color: 'white',\r\n        fontSize: '25px',\r\n        fontWeight: 300,\r\n        padding: '0px 30px',\r\n    },\r\n    buttonContainer: {\r\n        height: '150px',\r\n        // display: 'flex',\r\n        justifySelf: 'center',\r\n        alignItems: 'center',\r\n        width: '100%',\r\n        display: 'inline-grid',\r\n        gridTemplateColumns: '200px calc(100% - 200px)'\r\n        //paddingLeft: '30px'\r\n    },\r\n    button: {\r\n        height: '80px',\r\n        width: '140px',\r\n        backgroundColor: 'black',\r\n        color: 'white',\r\n        fontSize: '17px',\r\n        fontWeight: 600,\r\n        borderStyle: 'none',\r\n        borderRadius: '48px',\r\n        // boxShadow: '0px 0px 2px -1px',\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        justifyContent: 'flex-start',\r\n        marginLeft: '30px'\r\n    },\r\n    downloadButton: {\r\n        width: '50px',\r\n        color: 'rgb(48 106 241 / 70%)',\r\n        boxShadow: 'none',\r\n        borderRadius: '18px',\r\n        background: 'white',\r\n        marginRight: '20px',\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        justifyContent: 'center',\r\n    }\r\n}\r\n\r\nexport default RecordNow;\r\n","import React from 'react';\r\n\r\nimport './App.css';\r\nimport RecordNow from './components/RecordNow'\r\n\r\nfunction App() {\r\n\r\n  return (\r\n    <div className=\"App\" style={styles.fullScreen}>\r\n      <RecordNow />\r\n    </div>\r\n  );\r\n}\r\n\r\nconst styles = {\r\n  fullScreen: {\r\n    //display: 'grid',\r\n    height: '100vh',\r\n    alignContent: 'center',\r\n    display: 'grid',\r\n    gridTemplateRows: '285px calc(100vh - 285px)',\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}